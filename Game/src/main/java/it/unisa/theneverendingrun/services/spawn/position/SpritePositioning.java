package it.unisa.theneverendingrun.services.spawn.position;

import com.badlogic.gdx.graphics.Texture;
import it.unisa.theneverendingrun.models.Sprite;
import it.unisa.theneverendingrun.models.SpriteType;
import it.unisa.theneverendingrun.models.hero.Hero;
import it.unisa.theneverendingrun.models.obstacle.Obstacle;

import java.util.concurrent.ThreadLocalRandom;

public class SpritePositioning {

    private final Hero hero;
    private float maxWidth;

    private Sprite lastSprite = null;
    private SpriteType lastSpriteType = null;

    public SpritePositioning(Hero hero, float maxWidth) {
        this.hero = hero;
        this.maxWidth = maxWidth;
    }


    /**
     * This method will randomly create and return a new obstacle. The obstacles are generated by following some
     * criteria, ensuring that the character can avoid it.
     * In addition, to the obstacle will be assigned the correct position, based on the reference measures given
     * during the creation of the obstaclesManager.
     *
     * @return A new Spawnable, with the correct position, null if the obstacle cannot be generated
     */
    public Sprite getSprite() {
        SpriteType newSpriteType = getAppropriateSpawnableType();
        if(newSpriteType == null){
            System.out.println("null");
            return null;
        }

        //SpawnCreationManager spawnCreationManager = new SpawnCreationManager(hero.getJumpMaxElevation(), hero.getMaxSlideRange());

        Sprite newSprite = null;
        switch (newSpriteType){
            case JUMPABLE:
                break;
            case SLIDABLE:
                System.out.println("slidable");
                newSprite = create(newSpriteType);
                break;
            case JUMPABLE_SLIDABLE:
                System.out.println("jump_slid");
                break;
            default:
                return null;
        }

        //fixme delete
        if(newSprite == null)
            return null;

        setPosition(newSprite, newSpriteType);
        lastSprite = newSprite;
        lastSpriteType = newSpriteType;
        return newSprite;
    }

    private Sprite create(SpriteType newSpriteType) {
        return new Obstacle(new Texture("images/forest/obstacles/jumpable.png"));
    }

    private void setPosition(Sprite newSprite, SpriteType newType){
        PositioningStrategy positioningStrategy;
        switch (newType){
            case JUMPABLE:
                positioningStrategy = new JumpablePositioningStrategy();
                break;
            case SLIDABLE:
                positioningStrategy = new SlidablePositioningStrategy();
                break;
            case JUMPABLE_SLIDABLE:
                positioningStrategy = new SlidableJumpablePositioningStrategy();
                break;
            default:
                return;
        }

        float y = positioningStrategy.getYCoordinate(newSprite, lastSpriteType, hero);
        newSprite.setY(y);
        newSprite.setX(maxWidth);
    }

    /**
     * This method is used to get the right type of obstacle that can be added to the path, following the conditions.
     * For example, if the last obstacle was a slidable one, we cannot put another right after it,
     * otherwise the player might not be able to pass.
     * Please, note that this method randomly decides to add or not an obstacle, even if it can added.
     *
     * @return The type of obstacle that can be added, null if none.
     */
    private SpriteType getAppropriateSpawnableType() {
        //If there isn't any obstacle on the screen, add one at random
        if (lastSprite == null || !lastSprite.isXAxisVisible()) {
            int random = ThreadLocalRandom.current().nextInt(SpriteType.values().length);
            return SpriteType.values()[random];
        }

        // Calculate the distance from the last obstacle. This distance is defined as the distance from the right
        // side of an obstacle to the left side of the view.
        int distance = (int) (maxWidth - lastSprite.getX() - lastSprite.getWidth());


        // If distance is zero, then we could add a jumpable or slidable obstacle, but only if the previous was jumpable
        if (distance == 0) {
            if (lastSpriteType == SpriteType.JUMPABLE) {
                //generating a value between -1 and 1, deciding what to add according to it
                int r = ThreadLocalRandom.current().nextInt(-1, 2);
                if (r == 0)
                    return null;
                if (r > 0)
                    return SpriteType.JUMPABLE;
                if (r < 0)
                    return SpriteType.SLIDABLE;
            }
            if (lastSpriteType == SpriteType.JUMPABLE_SLIDABLE) {
                return null;
            }
            if (lastSpriteType == SpriteType.SLIDABLE) {
                return null;
            }
        }

        // If the obstacle is distant enough, it is possible to add every type of obstacle
        if (distance >= hero.getStandardWidth() * 3) {
            if (ThreadLocalRandom.current().nextInt() % 50 == 0) {
                int random = ThreadLocalRandom.current().nextInt(0, SpriteType.values().length);
                return SpriteType.values()[random];
            }
        }

        // else it will return null, since nothing can be added
        return null;
    }
}
